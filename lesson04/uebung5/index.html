<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>WebGL using tdl.js</title>
    <script type="text/javascript" src="../tdl/base.js"></script>
    <script type="text/javascript" src="../tdl/gl-matrix.js"></script>
    <script src="../jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="tdlUtils.js"></script>
    <script type="text/javascript" src="uebung5.js"></script>

    <style type="text/css">
        #error { display: none; }
        #canvas { border: 1px solid black; }
    </style>


</head>

<body>
<div class="container">
    <pre id="error" class="alert alert-error"></pre>

    <div id="canvas-container">
        <p><canvas id="canvas" width="600" height="600"></canvas></p>

    </div>
</div>
</body>

<!-- Cell Shading -->

<script id="vs0" type="x-shader/x-vertex">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;
    
    uniform int waterview;

    const int LIGHT_NUM = 3;

    uniform float lightPositions[3 * LIGHT_NUM];
    uniform float lightColors[3 * LIGHT_NUM];
    uniform vec3 eyePosition;

    attribute vec2 texCoord;
    attribute vec4 position;
    attribute vec3 normal;
    attribute vec3 tangent;
    attribute vec3 binormal;

    varying vec3 normalW;
    varying vec4 positionW;
    varying float lightDirectionW[3 * LIGHT_NUM];
    varying vec3 eyeDirectionW;
    varying mat3 tbn;
    varying vec2 texCoordI;

    void main() {
        positionW = model * position;
        normalW = (model * vec4(normal, 0.0)).xyz;
        vec3 binormalW = (model * vec4(binormal, 0.0)).xyz;
        vec3 tangentW = (model * vec4(tangent, 0.0)).xyz;
        tbn = mat3(tangentW, binormalW, normalW);
        
        if(waterview == 1){
            vec4 positionFlipped = position;
            positionW.y *= -1.0;
        }
        
        for(int i=0; i<3*LIGHT_NUM; i+=3){
            lightDirectionW[i  ] = lightPositions[i  ] - positionW.x;
            lightDirectionW[i+1] = lightPositions[i+1] - positionW.y;
            lightDirectionW[i+2] = lightPositions[i+2] - positionW.z;
        }
        eyeDirectionW = eyePosition - positionW.xyz;

        texCoordI = texCoord;
        gl_Position = projection * view * positionW;
    }
</script>

<script id="fs0" type="x-shader/x-fragment">
    precision highp  float;

    const int LIGHT_NUM = 3;
    const float textureRepeat = 5.0;
    const float bumpStrength = 20.0;

    uniform sampler2D texture;
    uniform sampler2D normalmap;
    uniform int useTextures;
    
    uniform vec3 color;
    uniform vec3 lightIntensity;
    uniform float brightpass;
    
    uniform float lightColors[3 * LIGHT_NUM];
    uniform int waterview;

    
    varying vec3 normalW;
    varying vec4 positionW;
    varying float lightDirectionW[3 * LIGHT_NUM];
    varying vec3 eyeDirectionW;
    varying mat3 tbn;
    varying vec2 texCoordI;

    vec3 lambert(vec3 normal, vec3 light, vec3 intensity, vec3 reflectivity) {
        float ndotl = dot(normal, light);
        return 0.5 * reflectivity * intensity * max(0.0, ndotl);
    }

    vec3 phong(vec3 normal, vec3 eye, vec3 light, vec3 intensity, vec3 reflectivity) {
        float vdotn = dot(reflect(-eye, normal), light);
        vec3 ambient = reflectivity * 0.03;
        vec3 specular = 0.7 * intensity * pow(max(0.0, vdotn), 10.2);
        return lambert(normal, light, intensity, reflectivity) + specular + ambient;
    }
    
    vec3 brightpass_filter(vec3 color){
        if((color.r + color.g + color.b)/3.0 < brightpass){
            return vec3(0.0,0.0,0.0);
        }
        return color;
    }

    uniform float time;

    void main() {
        
        if(waterview == 1 && positionW.y > 0.0){
            discard;
        }
        
        vec3 normal = normalW;
        vec3 fragcolor = color;
        if(useTextures == 1){
            normal = tbn * (texture2D(normalmap, texCoordI * textureRepeat).xyz * bumpStrength);
            fragcolor = (texture2D(texture, texCoordI * textureRepeat).rgb );
        }
        
        vec3 outcolor = vec3(0.0,0.0,0.0);
        for(int i=0; i<3*LIGHT_NUM; i+=3){
            vec3 lightColor = vec3(lightColors[i],lightColors[i+1],lightColors[i+2]);
            vec3 lightDirection = vec3(lightDirectionW[i],lightDirectionW[i+1],lightDirectionW[i+2]);
            outcolor += phong(
                normalize(normal),
                normalize(eyeDirectionW),
                normalize(lightDirection),
                lightColor,
                fragcolor);
        }
        
        gl_FragColor.rgb = brightpass_filter(outcolor);
        gl_FragColor.a = 1.0;
    }
</script>

<script id="vs1" type="x-shader/x-vertex">
    attribute vec4 position;
    varying vec2 texCoordI;

    void main() {
    texCoordI = (position.xy + 1.0) / 2.0;
    gl_Position = position;
    }
</script>

<script id="fs1" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoordI;
    uniform sampler2D colorBuffer;
    uniform sampler2D glowMap;
    uniform sampler2D waterMap;
    uniform int showReflectiveTex;
    
    const vec2 reflTexUL = vec2(0.1,0.1);
    const vec2 reflTexBR = vec2(0.3,0.3);
    
    uniform float glowStrength;

    void main() {
        vec3 glowmapPixel = texture2D(glowMap, texCoordI).rgb;
        vec3 origPixel = texture2D(colorBuffer, texCoordI).rgb;
        gl_FragColor.rgb = glowmapPixel * glowStrength + origPixel;
        if(showReflectiveTex == 1){
            if( texCoordI.x > reflTexUL.x &&
                texCoordI.y > reflTexUL.y &&
                texCoordI.x < reflTexBR.x &&
                texCoordI.y < reflTexBR.y
                ){
                vec2 screenTexCoord = (texCoordI.xy * reflTexBR) - reflTexUL;
                gl_FragColor.rgb = texture2D(waterMap, screenTexCoord).rgb;
            }
        }
        gl_FragColor.a = 1.0;
    }
</script>

<script id="vs2" type="x-shader/x-vertex">
    attribute vec4 position;
    varying vec2 texCoordI;

    void main() {
        texCoordI = (position.xy + 1.0) / 2.0;
        gl_Position = position;
    }
</script>

<script id="fs2" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoordI;
    uniform sampler2D colorBuffer;
    

    uniform float glowBlurSize;
    const int samples = 5;
    const float center = (float(samples)-1.0)/2.0;
    
    void main() {
        
        vec3 color = vec3(0.0);
        for (int x = 0; x < samples; x++) {
            for (int y = 0; y < samples; y++) {
                float xx = (float(x) - center)*glowBlurSize;
                float yy = (float(y) - center)*glowBlurSize;
                vec2 tc = texCoordI + vec2(xx, yy);
                float kernelWeight = 1.0 / (abs(xx)+abs(yy)+1.0);
                color += texture2D(colorBuffer, tc).rgb * kernelWeight;
            }
        }

        gl_FragColor.rgb = (color / float(samples * samples));
        gl_FragColor.a = 1.0;
    }
</script>

<script id="vs3" type="x-shader/x-vertex">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;
    uniform vec3 eyePosition;
    uniform mat4 invModelView;
    uniform float time;

    attribute vec2 texCoord;
    attribute vec4 position;
    attribute vec3 normal;
    attribute vec3 binormal;
    attribute vec3 tangent;

    varying vec4 positionW;
    varying vec3 eyeDirectionW;
    varying mat3 tbn;
    varying vec2 texCoordI;
    varying vec2 reflectionI;

    const float WAVE_HEIGHT = 0.05;
    const float WAVE_SPEED = 1.0;
    const float WAVE_LENGTH = 0.2;

    void main() {
        positionW = model * position;
        positionW.y += sin(WAVE_LENGTH * positionW.x*5.143 + WAVE_SPEED * time * 2.8234)*WAVE_HEIGHT + WAVE_HEIGHT;
        positionW.y += cos(WAVE_LENGTH * positionW.z*3.322 + WAVE_SPEED * time * 3.3934)*WAVE_HEIGHT + WAVE_HEIGHT;
        vec3 normalW = (model * vec4(normal, 0.0)).xyz;
        vec3 binormalW = (model * vec4(binormal, 0.0)).xyz;
        vec3 tangentW = (model * vec4(tangent, 0.0)).xyz;
        tbn = mat3(tangentW, binormalW, normalW);
        eyeDirectionW = eyePosition - positionW.xyz;
        vec4 viewvec = view * positionW;
        gl_Position = projection * viewvec;
        texCoordI = texCoord;
        reflectionI = ((gl_Position.xy / (gl_Position.z)) + vec2(1.0, 1.0)) / 2.0;
    }
</script>

<script id="fs3" type="x-shader/x-fragment">
    precision highp float;
    
    const float REFLECTION_DIMMING = 0.5;

    varying vec4 positionW;
    varying vec3 eyeDirectionW;
    varying mat3 tbn;
    varying vec2 texCoordI;
    varying vec2 reflectionI;
    
    uniform float time;
    uniform sampler2D waterMap;
    uniform sampler2D waterNormal;
    
    const float waterSpeed = 0.02;
    const float waterStrength = 0.04;

    vec2 makeWave(float time, vec2 coord){
        return vec2(
            ((
                sin(cos(time*0.65+coord.y)*11.0 + sin(time*0.12+coord.x))
            ) +1.0 ) / 2.0,
            ((
                cos(sin(time*0.1+coord.x)*12.0 + cos(time * 0.43 + coord.y))
            ) +1.0 ) / 2.0
        );
    }

    void main() {
        vec2 waterNormalCoord = texCoordI.xy + vec2(1.0,1.0) * time * waterSpeed;
        vec3 textureNormal = (texture2D(waterNormal, waterNormalCoord).rgb - vec3(0.5,0.5,0.5)) * 2.0;
        textureNormal = normalize(tbn * textureNormal);
        vec2 reflTexCoord = clamp(reflectionI.xy + (textureNormal.xy * waterStrength), 0.001, 0.999);
        gl_FragColor.rgb = texture2D(waterMap, reflTexCoord).rgb * REFLECTION_DIMMING;
        float reflectionAngle = 30.0;
        float transparency = 1.0 - dot(eyeDirectionW, tbn * vec3(0.0,0.0,1.0)) / reflectionAngle;
        /*transparency /= 10.0;
        if(transparency<0.0){
            transparency = 0.0;
        }
        if(transparency>1.0){
            transparency = 1.0;
        }*/
        gl_FragColor.a = transparency;
    }
</script>

<script id="vs4" type="x-shader/x-vertex">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;

    uniform vec3 eyePosition;

    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 eyeDirectionW;

    void main() {
    vec4 positionW = model * position * 10.0;
    eyeDirectionW = - position.xyz;
    gl_Position = projection * view * positionW;
    }
</script>

<script id="fs4" type="x-shader/x-fragment">
    precision highp  float;

    uniform samplerCube cubemap;

    varying vec3 eyeDirectionW;

    void main() {
        vec4 cubeMapColor = textureCube(cubemap, -eyeDirectionW);
        gl_FragColor.rgb = cubeMapColor.rgb;
        gl_FragColor.a = 1.0;
    }
</script>

</html>
