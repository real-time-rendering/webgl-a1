<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>WebGL using tdl.js</title>
    <script type="text/javascript" src="../tdl/base.js"></script>
    <script type="text/javascript" src="../tdl/gl-matrix.js"></script>
    <script src="../jquery-1.9.1.min.js"></script>

    <style type="text/css">
        #error { display: none; }
        #canvas { border: 1px solid black; }
    </style>

    <script type="text/javascript" src="tdlUtils.js"></script>
    <script type="text/javascript" src="uebung5.js"></script>
</head>

<body>
<div class="container">
    <pre id="error" class="alert alert-error"></pre>

    <div id="canvas-container">
        <p><canvas id="canvas" width="600" height="600"></canvas></p>
    </div>
</div>
</body>

<!-- Cell Shading -->

<script id="vs0" type="x-shader/x-vertex">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;
    
    uniform int waterview;

    const int LIGHT_NUM = 4;

    uniform float lightPositions[3 * LIGHT_NUM];
    uniform float lightColors[3 * LIGHT_NUM];
    uniform vec3 eyePosition;

    attribute vec2 texCoord;
    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 normalW;
    varying vec4 positionW;
    varying float lightDirectionW[3 * LIGHT_NUM];
    varying vec3 eyeDirectionW;

    varying vec2 texCoordI;

    void main() {
        positionW = model * position;
        normalW = (model * vec4(normal, 0.0)).xyz;
        if(waterview > 0){
            vec4 positionFlipped = position;
            positionW.y *= -1.0;
            normalW.y *= -1.0;
        }
        
        for(int i=0; i<3*LIGHT_NUM; i+=3){
            lightDirectionW[i  ] = lightPositions[i  ] - positionW.x;
            lightDirectionW[i+1] = lightPositions[i+1] - positionW.y;
            lightDirectionW[i+2] = lightPositions[i+2] - positionW.z;
        }
        eyeDirectionW = eyePosition - positionW.xyz;

        texCoordI = texCoord;
        gl_Position = projection * view * positionW;
    }
</script>

<script id="fs0" type="x-shader/x-fragment">
    precision highp  float;

    const int LIGHT_NUM = 4;

    uniform vec3 color;
    uniform vec3 lightIntensity;
    uniform float brightpass;
    
    uniform int waterview;

    varying vec3 normalW;
    varying vec4 positionW;
    varying float lightDirectionW[LIGHT_NUM*3];
    uniform float lightColors[3 * LIGHT_NUM];
    varying vec3 eyeDirectionW;

    varying vec2 texCoordI;

    vec3 lambert(vec3 normal, vec3 light, vec3 intensity, vec3 reflectivity) {
        float ndotl = dot(normal, light);
        return 0.1 * reflectivity * intensity + 0.6 * reflectivity * intensity * max(0.0, ndotl);
    }

    vec3 phong(vec3 normal, vec3 eye, vec3 light, vec3 intensity, vec3 reflectivity) {
        float vdotn = dot(reflect(-eye, normal), light);

        vec3 specular = 0.6 * intensity * pow(max(0.0, vdotn), 1.0);
        return lambert(normal, light, intensity, reflectivity) + specular;
    }
    
    vec3 brightpass_filter(vec3 color){
        if((color.r + color.g + color.b)/3.0 < brightpass){
            return vec3(0.0,0.0,0.0);
        }
        return color;
    }

    uniform float time;

    void main() {
        
        if(waterview == 1 && positionW.y > 0.0){
            discard;
        }
        
        vec3 outcolor = vec3(0.0,0.0,0.0);
        for(int i=0; i<3*LIGHT_NUM; i+=3){
            vec3 lightColor = vec3(lightColors[i],lightColors[i+1],lightColors[i+2]);
            vec3 lightDirection = vec3(lightDirectionW[i],lightDirectionW[i+1],lightDirectionW[i+2]);
            outcolor += phong(
                normalize(normalW),
                normalize(eyeDirectionW),
                normalize(lightDirection),
                lightColor, color);
        }

        gl_FragColor.rgb = brightpass_filter(outcolor);
        gl_FragColor.a = 1.0;
    }
</script>

<script id="vs1" type="x-shader/x-vertex">
    attribute vec4 position;
    varying vec2 texCoordI;

    void main() {
    texCoordI = (position.xy + 1.0) / 2.0;
    gl_Position = position;
    }
</script>

<script id="fs1" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoordI;
    uniform sampler2D colorBuffer;
    uniform sampler2D glowMap;
    uniform sampler2D waterMap;
    uniform int showReflectiveTex;
    
    const vec2 reflTexUL = vec2(0.1,0.1);
    const vec2 reflTexBR = vec2(0.3,0.3);
    
    uniform float glowStrengh;

    void main() {
        vec3 glowmapPixel = texture2D(glowMap, texCoordI).rgb;
        vec3 origPixel = texture2D(colorBuffer, texCoordI).rgb;
        gl_FragColor.rgb = glowmapPixel * glowStrengh + origPixel;
        if(showReflectiveTex == 1){
            if( texCoordI.x > reflTexUL.x &&
                texCoordI.y > reflTexUL.y &&
                texCoordI.x < reflTexBR.x &&
                texCoordI.y < reflTexBR.y
                ){
                vec2 screenTexCoord = (texCoordI.xy * reflTexBR) - reflTexUL;
                gl_FragColor.rgb = texture2D(waterMap, screenTexCoord).rgb;
            }
        }
        gl_FragColor.a = 1.0;
    }
</script>

<script id="vs2" type="x-shader/x-vertex">
    attribute vec4 position;
    varying vec2 texCoordI;

    void main() {
        texCoordI = (position.xy + 1.0) / 2.0;
        gl_Position = position;
    }
</script>

<script id="fs2" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoordI;
    uniform sampler2D colorBuffer;
    

    uniform float glowBlurSize;
    const int samples = 5;
    const float center = (float(samples)-1.0)/2.0;
    
    void main() {
        vec3 color = vec3(0.0);
        for (int x = 0; x < samples; x++) {
            for (int y = 0; y < samples; y++) {
                float xx = (float(x) - center)*glowBlurSize;
                float yy = (float(y) - center)*glowBlurSize;
                vec2 tc = texCoordI + vec2(xx, yy);
                color += texture2D(colorBuffer, tc).rgb;
            }
        }

        gl_FragColor.rgb = (color / float(samples * samples));
        gl_FragColor.a = 1.0;
    }
</script>

<script id="vs3" type="x-shader/x-vertex">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;
    uniform vec3 eyePosition;
    uniform mat4 invModelView;

    attribute vec2 texCoord;
    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 normalW;
    varying vec3 eyeDirectionW;

    varying vec2 texCoordI;
    varying vec2 reflectionI;

    void main() {
        vec4 positionW = model * position;
        normalW = (model * vec4(normal, 0.0)).xyz;
        eyeDirectionW = eyePosition - positionW.xyz;
        vec4 viewvec = view * positionW;
        gl_Position = projection * viewvec;
        texCoordI = texCoord;
        reflectionI = ((gl_Position.xy / gl_Position.z) + vec2(1.0, 1.0)) / 2.0; //texCoord; //(invModelView * position).xy;
    }
</script>

<script id="fs3" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoordI;
    varying vec2 reflectionI;
    uniform float time;
    uniform sampler2D waterMap;
    uniform sampler2D waterNormal;
    
    const float waterSpeed = 0.02;
    const float waterStrength = 0.1;

    vec2 makeWave(float time, vec2 coord){
        return vec2(
            ((
                sin(cos(time*0.65+coord.y)*11.0 + sin(time*0.12+coord.x))
            ) +1.0 ) / 2.0,
            ((
                cos(sin(time*0.1+coord.x)*12.0 + cos(time * 0.43 + coord.y))
            ) +1.0 ) / 2.0
        );
    }

    void main() {
        vec2 waterNormalCoord = texCoordI.xy;
        waterNormalCoord += vec2(1.0,1.0) * time * waterSpeed;
        vec3 textureNormal = texture2D(waterNormal, waterNormalCoord).rgb;
        gl_FragColor.rgb = texture2D(waterMap, (reflectionI.xy)+textureNormal.xy * waterStrength).rgb;
        //gl_FragColor.rgb = texture2D(waterMap, texCoordI.xy).rgb;
        //some grey to see the reflective surface
        
        
        //gl_FragColor.b = makeWave(time, texCoordI.xy).x + makeWave(time, texCoordI.xy).y;
        //gl_FragColor.rg = vec2(0.0, 0.0);
        gl_FragColor.a = 1.0;
    }
</script>

</html>
