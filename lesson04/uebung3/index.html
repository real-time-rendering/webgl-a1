
<!--
A WebGL example using tdl.js (http://code.google.com/p/threedlibrary/).

author: Henrik Tramberend (tramberend@beuth-hochschule.de)
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>WebGL using tdl.js</title>
    <script type="text/javascript" src="tdl/base.js"></script>
    <script type="text/javascript" src="tdl/gl-matrix.js"></script>
    <script src="../jquery-1.9.1.min.js"></script>

    <style type="text/css">
        #error { display: none; }
        #canvas { border: 1px solid black; }
    </style>

    <script type="text/javascript" src="uebung3.js"></script>
</head>

<body>
<div class="container">
    <pre id="error" class="alert alert-error"></pre>

    <div id="canvas-container">
        <p><canvas id="canvas" width="600" height="500"></canvas></p>
    </div>
</div>
</body>

<!-- Cell Shading -->

<script id="vs0" type="x-shader/x-vertex">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;
    
    const int LIGHT_NUM = 4;

    uniform float lightPositions[3 * LIGHT_NUM];
    uniform float lightColors[3 * LIGHT_NUM];
    uniform vec3 eyePosition;

    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 normalW;
    varying float lightDirectionW[3 * LIGHT_NUM];
    varying vec3 eyeDirectionW;

    void main() {
        vec4 positionW = model * position;
        normalW = (model * vec4(normal, 0.0)).xyz;
        for(int i=0; i<3*LIGHT_NUM; i+=3){
            lightDirectionW[i  ] = lightPositions[i  ] - positionW.x;
            lightDirectionW[i+1] = lightPositions[i+1] - positionW.y;
            lightDirectionW[i+2] = lightPositions[i+2] - positionW.z;
        }
        eyeDirectionW = eyePosition - positionW.xyz;

        gl_Position = projection * view * positionW;
    }
</script>

<script id="fs0" type="x-shader/x-fragment">
    precision highp float;
    
    const int LIGHT_NUM = 4;

    uniform vec3 color;
    uniform vec3 lightIntensity;

    varying vec3 normalW;
    varying float lightDirectionW[LIGHT_NUM*3];
    uniform float lightColors[3 * LIGHT_NUM];
    varying vec3 eyeDirectionW;
    
    float discrete(float f, float steps){
        return float(int(f*steps + 0.5)) / steps;
    }
    
    vec3 discrete(vec3 c, float steps){
        return vec3(
            discrete(c.r, steps),
            discrete(c.g, steps),
            discrete(c.b, steps)
        );
    }

    vec3 lambert(vec3 normal, vec3 light, vec3 intensity, vec3 reflectivity) {
        float ndotl = dot(normal, light);
        return 0.1 * reflectivity * intensity +
               0.6 * reflectivity * intensity * max(0.0, ndotl);
    }

    vec3 phong(vec3 normal, vec3 eye, vec3 light, vec3 intensity, vec3 reflectivity) {
        float vdotn = dot(reflect(-eye, normal), light);
        float outline = dot(normal, eye);
        if(outline < 0.3){
            return vec3(0.0, 0.0, 0.0);
        }
        vec3 specular = 0.6 * intensity * pow(max(0.0, vdotn), 1.0);
        return lambert(normal, light, intensity, reflectivity) + specular;
    }

    void main() {
        vec3 outcolor = vec3(0.0,0.0,0.0);
        for(int i=0; i<3*LIGHT_NUM; i+=3){
            vec3 lightColor = vec3(lightColors[i],lightColors[i+1],lightColors[i+2]);
            vec3 lightDirection = vec3(lightDirectionW[i],lightDirectionW[i+1],lightDirectionW[i+2]);
            outcolor += phong(
                normalize(normalW),
                normalize(eyeDirectionW),
                normalize(lightDirection),
                lightColor, color
            );
        }
        gl_FragColor.rgb = discrete(outcolor, 3.0);
        gl_FragColor.a = 1.0;
    }
</script>

<!-- Lambert lighting model, Gouraud shading -->

<script id="vs1" type="text/glsl">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;

    uniform vec3 color;
    uniform vec3 lightIntensity;
    uniform vec3 lightPosition;
    uniform vec3 eyePosition;

    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 intensity;

    vec3 lambert(vec3 normal, vec3 light,
    vec3 intensity, vec3 reflectivity) {
    return 0.1 * reflectivity * intensity +
    0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
    }

    void main() {
    vec3 normalW = (model * vec4(normal, 0.0)).xyz;
    vec4 positionW = model * position;
    vec3 lightDirectionW = normalize(lightPosition - positionW.xyz);

    intensity = lambert(normalW, lightDirectionW, lightIntensity, color);
    gl_Position = projection * view * positionW;
    }
</script>

<script id="fs1" type="text/glsl">
    precision highp float;

    varying vec3 intensity;

    void main() {
    gl_FragColor.rgb = intensity;
    gl_FragColor.a = 1.0;
    }
</script>

<!-- Phong lighting model, Gouraud shading -->

<script id="vs2" type="text/glsl">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;

    uniform vec3 color;
    uniform vec3 lightIntensity;
    uniform vec3 lightPosition;
    uniform vec3 eyePosition;

    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 intensity;

    vec3 lambert(vec3 normal, vec3 light, vec3 intensity, vec3 reflectivity) {
        return 0.1 * reflectivity * intensity + 0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
    }

    vec3 phong(vec3 normal, vec3 eye, vec3 light, vec3 intensity, vec3 reflectivity) {
        return lambert(normal, light, intensity, reflectivity) + 0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal), light)), 10.0);
    }

    void main() {
        vec3 normalW = (model * vec4(normal, 0.0)).xyz;
        vec4 positionW = model * position;
        vec3 lightDirectionW = normalize(lightPosition - positionW.xyz);
        vec3 eyeDirectionW = normalize(eyePosition - positionW.xyz);

        intensity = phong(normalW, eyeDirectionW, lightDirectionW, lightIntensity, color);
        gl_Position = projection * view * positionW;
    }
</script>

<script id="fs2" type="text/glsl">
    precision highp float;

    varying vec3 intensity;

    void main() {
        gl_FragColor.rgb = intensity;
        gl_FragColor.a = 1.0;
    }
</script>

<!-- Phong lighting model, Phong shading -->

<script id="vs3" type="text/glsl">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;

    uniform vec3 lightPosition;
    uniform vec3 eyePosition;

    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 normalW;
    varying vec3 lightDirectionW;
    varying vec3 eyeDirectionW;

    void main() {
    vec4 positionW = model * position;
    normalW = (model * vec4(normal, 0.0)).xyz;
    lightDirectionW = lightPosition - positionW.xyz;
    eyeDirectionW = eyePosition - positionW.xyz;

    gl_Position = projection * view * positionW;
    }
</script>

<script id="fs3" type="text/glsl">
    precision highp float;

    uniform vec3 color;
    uniform vec3 lightIntensity;

    varying vec3 normalW;
    varying vec3 lightDirectionW;
    varying vec3 eyeDirectionW;

    vec3 lambert(vec3 normal, vec3 light,
    vec3 intensity, vec3 reflectivity) {
    return 0.1 * reflectivity * intensity +
    0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
    }

    vec3 phong(vec3 normal, vec3 eye, vec3 light,
    vec3 intensity, vec3 reflectivity) {
    return lambert(normal, light, intensity, reflectivity) +
    0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal),
    light)), 10.0);
    }

    void main() {
    gl_FragColor.rgb = phong(
    normalize(normalW),
    normalize(eyeDirectionW),
    normalize(lightDirectionW),
    lightIntensity, color);
    gl_FragColor.a = 1.0;
    }
</script>

<!-- Phong lighting model, Phong shading with texture -->

<script id="vs4" type="text/glsl">
    uniform mat4 projection;
    uniform mat4 view;
    uniform mat4 model;

    uniform vec3 lightPosition;
    uniform vec3 eyePosition;

    attribute vec4 position;
    attribute vec3 normal;
    attribute vec2 texCoord;

    varying vec3 normalW;
    varying vec3 lightDirectionW;
    varying vec3 eyeDirectionW;
    varying vec2 texCoordI;

    void main() {
    vec4 positionW = model * position;
    normalW = (model * vec4(normal, 0.0)).xyz;
    lightDirectionW = lightPosition - positionW.xyz;
    eyeDirectionW = eyePosition - positionW.xyz;

    texCoordI = texCoord;
    gl_Position = projection * view * positionW;
    }
</script>

<script id="fs4" type="text/glsl">
    precision highp float;

    uniform vec3 lightIntensity;

    uniform sampler2D earth;

    varying vec3 normalW;
    varying vec3 lightDirectionW;
    varying vec3 eyeDirectionW;
    varying vec2 texCoordI;

    vec3 lambert(vec3 normal, vec3 light,
    vec3 intensity, vec3 reflectivity) {
    return 0.1 * reflectivity * intensity +
    0.6 * reflectivity * intensity * max(0.0, dot(normal, light));
    }

    vec3 phong(vec3 normal, vec3 eye, vec3 light,
    vec3 intensity, vec3 reflectivity) {
    return lambert(normal, light, intensity, reflectivity) +
    0.3 * intensity * pow(max(0.0, dot(reflect(-eye, normal),
    light)), 10.0);
    }

    void main() {
    vec3 color = texture2D(earth, texCoordI).rgb;

    gl_FragColor.rgb = phong(
    normalize(normalW),
    normalize(eyeDirectionW),
    normalize(lightDirectionW),
    lightIntensity, color);
    gl_FragColor.a = 1.0;
    }
</script>

</html>
